# 16인 상호 평가 시스템 - 상세 작업 내역

## 목차
1. [프로젝트 개요](#1-프로젝트-개요)
2. [데이터 저장 및 UX 개선](#2-데이터-저장-및-ux-개선)
3. [그래프 겹침 개선](#3-그래프-겹침-개선)
4. [기술 구현 상세](#4-기술-구현-상세)
5. [파일 구조 및 의존성](#5-파일-구조-및-의존성)

---

## 1. 프로젝트 개요

### 1.1 앱 소개
- **이름**: 16인 상호 평가 시스템
- **목적**: 16명의 참가자가 서로를 0~100점 척도로 평가하고, 결과를 시각화
- **주요 화면**: 평가자 선택 → 점수 입력(슬라이더/숫자) → 점수 분포 그래프 표시

### 1.2 참가자 목록 (하드코딩)
```
지운, 대성, 준호, 하운, 병주, 형진, 태욱, 승재, 현우, 
태현, 상혁, 승희, 가람, 효민, 웅, 준이형, 한을
```

### 1.3 데이터 구조
- **allEvaluations**: `Record<평가자, Record<대상, 점수>>`
- **axisLabel**: 평가 기준 이름 (예: "식 점수", "매력도")

---

## 2. 데이터 저장 및 UX 개선

### 2.1 localStorage 자동 저장

#### 목적
브라우저를 닫거나 새로고침해도 입력한 평가 데이터가 유지되도록 함.

#### 구현 상세

**저장 키**
```typescript
const STORAGE_KEY = 'score-graph-evaluations';
```

**저장 대상**
- `allEvaluations`: 전체 평가 행렬
- `axisLabel`: 현재 축 라벨

**저장 시점**
- `allEvaluations` 또는 `axisLabel`이 변경될 때마다 `useEffect`에서 자동 저장

**로드 시점**
- 초기 `useState` 콜백에서 `localStorage.getItem(STORAGE_KEY)`로 복원
- 파싱 실패 시 기본 데이터 사용 (`getInitialData()`)

**에러 처리**
- `localStorage.setItem` 실패 시 (저장 공간 부족 등) 토스트로 "저장 공간이 부족합니다." 표시

**UI 반영**
- 헤더 부제목에 "· 자동 저장" 문구 추가
- 사용자에게 데이터가 자동 저장된다는 인지 제공

---

### 2.2 숫자 직접 입력

#### 목적
슬라이더만으로는 정확한 값 입력이 어려우므로, 0~100 범위 숫자를 직접 입력할 수 있게 함.

#### 구현 상세

**입력 필드**
- 각 참가자별 슬라이더 위에 `type="number"` input 추가
- `min={0}`, `max={100}`으로 범위 제한
- 폭: `w-12` (48px), 우측 정렬, `font-mono`

**onChange 처리**
```typescript
onChange={(e) => {
  const v = parseInt(e.target.value, 10);
  if (!isNaN(v)) updateScore(person.name, Math.min(100, Math.max(0, v)));
}}
```
- 숫자만 허용, 0~100으로 클램핑

**onBlur 처리**
```typescript
onBlur={(e) => {
  const v = parseInt(e.target.value, 10);
  if (isNaN(v) || e.target.value === '') updateScore(person.name, 0);
}}
```
- 빈 칸이나 비정상 입력 시 0으로 복원

**스타일**
- 스피너 제거: `[appearance:textfield] [&::-webkit-inner-spin-button]:appearance-none`
- 포커스 시 `ring-emerald-500` 테두리

---

### 2.3 평가 완료 표시

#### 목적
누가 아직 평가하지 않았는지 한눈에 파악할 수 있도록 표시.

#### 구현 상세

**완료 여부 계산**
```typescript
const hasEvaluated = useMemo(() => {
  const result: Record<string, boolean> = {};
  participantsNames.forEach(name => {
    const evals = allEvaluations[name] || {};
    const sum = Object.values(evals).reduce((a, b) => a + b, 0);
    result[name] = sum > 0;
  });
  return result;
}, [allEvaluations]);
```
- 해당 평가자가 준 점수의 합이 0보다 크면 "평가 완료"로 간주

**표시**
- 평가 완료한 사람 옆에 `Check` 아이콘 (emerald 색, 12px)
- `title="평가 완료"` 툴팁

---

### 2.4 가져오기 시 덮어쓰기 경고

#### 목적
이미 입력된 데이터가 있는데 JSON을 불러오면 덮어쓰므로, 실수를 방지하기 위해 확인 절차 추가.

#### 구현 상세

**조건**
- 현재 `allEvaluations` 중 하나라도 0이 아닌 점수가 있을 때만 확인

**확인 메시지**
```text
현재 데이터가 있습니다. 불러온 데이터로 덮어쓰시겠습니까?
```

**처리**
- "취소" → 아무 변경 없음, `event.target.value = ''`로 같은 파일 재선택 가능
- "확인" → `setAllEvaluations`, `setAxisLabel` 실행, 토스트 "파일을 성공적으로 불러왔습니다."

---

### 2.5 토스트 알림

#### 목적
`alert` 대신 시각적 피드백을 제공하여 UX를 완화.

#### 구현 상세

**상태**
```typescript
const [toast, setToast] = useState<{ message: string; type: 'success' | 'error' } | null>(null);
```

**표시 시간**
- 2.5초 후 자동 제거 (`setTimeout`)

**표시 위치**
- 화면 하단 중앙, `fixed bottom-6 left-1/2 -translate-x-1/2`

**스타일**
- 성공: `bg-emerald-600`, 실패: `bg-red-500`
- `z-50`으로 다른 요소 위에 표시

**적용 구간**
- 이미지 저장 성공/실패
- JSON 내보내기 성공
- JSON 불러오기 성공/실패
- localStorage 저장 실패

---

### 2.6 빈 상태 처리

#### 목적
아무도 평가하지 않았을 때 리더보드가 비어 보이지 않도록 안내 문구 표시.

#### 구현 상세

**조건**
```typescript
Object.values(hasEvaluated).some(Boolean)
```
- 한 명이라도 평가를 완료했으면 리더보드 표시, 아니면 빈 상태 문구 표시

**빈 상태 문구**
```text
아직 평가가 없습니다.
왼쪽에서 평가자를 선택한 뒤
점수를 입력해 보세요.
```

**스타일**
- `text-emerald-200/80`, `text-xs`, `leading-relaxed`

---

### 2.7 기타 개선

| 항목 | 변경 전 | 변경 후 |
|------|---------|---------|
| 페이지 타이틀 | cleaning-tool-score | 16인 상호 평가 시스템 |
| html lang | en | ko |
| 축 라벨 input | - | placeholder="예: 식 점수" |
| 이미지 저장 버튼 | title만 | title + aria-label="그래프 이미지로 저장" |
| 그래프 Tip | 기술 설명 위주 | "슬라이더나 숫자 칸으로 점수를 입력하면 그래프에 바로 반영됩니다." 등 간단 안내 |

---

## 3. 그래프 겹침 개선

### 3.1 세로 칩 나열 (4번 방식)

#### 배경
겹침 표현 후보: ①호버 툴팁 ②숫자 배지 ③괄호/구름 ④세로 칩 나열  
→ ④세로 칩 나열 채택.

#### 목적
점수가 비슷한 사람들을 한 세로 블록에 칩 형태로 모아 가로 겹침을 줄임.

#### 구현 상세

**그룹화 기준**
- `SCORE_BAND = 12`: 점수 차이가 12 이내면 같은 그룹

**그룹화 알고리즘**
```typescript
// 점수 오름차순 정렬
const sorted = [...currentScores].sort((a, b) => a.score - b.score || a.name.localeCompare(b.name));

// 인접 항목이 SCORE_BAND 이내면 같은 그룹으로 병합
for (const person of sorted) {
  const inRange = currentGroup.length > 0 && 
    Math.abs(person.score - currentGroup[currentGroup.length - 1].score) <= SCORE_BAND;
  if (inRange) currentGroup.push(person);
  else {
    if (currentGroup.length > 0) groups.push(currentGroup);
    currentGroup = [person];
  }
}
```

**단일 vs 클러스터**
- `members.length === 1` → 단일 (기존 점+라벨 스타일 유지)
- `members.length > 1` → 클러스터 (세로 칩 블록)

**클러스터 위치**
- `centerX = members의 점수 평균` (0~100% 구간 내로 클램핑)

**클러스터 칩 구성**
- 칩 하나: `색점 + 이름 + 점수`
- `flex-col-reverse`: 낮은 점수 칩이 축에 가깝게, 높은 점수가 위로
- 연결선: `h-4` (16px) 세로선

---

### 3.2 가로 겹침 대응

#### 문제
그룹에 포함되지 않은 단일 항목끼리 점수가 가까우면 라벨이 가로로 겹침.

#### 해결: 세로 스태거

**파라미터**
- `STAGGER_THRESHOLD = 18`: 점수 차이 18 이내면 "가까움"
- `VERTICAL_OFFSET = 26`: 번갈아 ±26px 세로 오프셋

**로직**
```typescript
// 가까운 단일 항목들을 점수 순 정렬
const nearby = singleIndices.filter((s) => Math.abs(s.x - x) < STAGGER_THRESHOLD)
  .sort((a, b) => a.x - b.x);

// 짝수 번째: +26px, 홀수 번째: -26px
if (myPos >= 0) yOffsets.set(idx, myPos % 2 === 0 ? VERTICAL_OFFSET : -VERTICAL_OFFSET);
```

**적용**
- 단일 항목의 라벨 컨테이너 높이에 `yOffset` 반영: `height: 36 + yOffset`

---

### 3.3 점 정확한 위치 배치

#### 문제
클러스터일 때 여러 점이 한 위치에 모여 있어 실제 점수와 맞지 않음.

#### 해결
라벨과 점을 분리 렌더링하고, 점만 항상 `person.score`%에 배치.

**레이어 구조**
1. 라벨 레이어: 단일/클러스터 칩만 (점 제거)
2. 점 레이어: `currentScores` 기준으로 각 점을 `left: ${person.score}%`에 배치

**점 렌더링**
```tsx
{currentScores.map((person) => (
  <div
    key={`dot-${person.name}`}
    className="absolute bottom-0 w-2.5 h-2.5 -translate-x-1/2 translate-y-1.5 rounded-full ..."
    style={{ left: `${person.score}%`, zIndex: person.score, backgroundColor: person.color }}
  />
))}
```

---

### 3.4 칩-점 간격 조정

#### 변경 사항
- 칩 아래 여백: `mb-2` (8px) → `mb-3` (12px)
- 단일 연결선 높이: 36px → 42px
- 클러스터 연결선: `h-2` (8px) → `h-4` (16px)

---

### 3.5 점 크기 축소

#### 변경
- `w-4 h-4` (16px) → `w-2.5 h-2.5` (10px)

#### 효과
- 점이 더 잘 분리되어 보이고, 가독성 향상

---

## 4. 기술 구현 상세

### 4.1 상수 요약

| 상수 | 값 | 용도 |
|------|----|------|
| STORAGE_KEY | score-graph-evaluations | localStorage 키 |
| SCORE_BAND | 12 | 같은 그룹(클러스터)으로 묶을 점수 차이 |
| STAGGER_THRESHOLD | 18 | 세로 스태거 적용할 최대 점수 차이 |
| VERTICAL_OFFSET | 26 | 스태거 시 위/아래 오프셋 (px) |
| 토스트 표시 시간 | 2500ms | 2.5초 후 자동 제거 |

### 4.2 graphDisplayItems 구조

```typescript
type DisplayItem =
  | { type: 'single'; person: Person; centerX: number; yOffset?: number }
  | { type: 'cluster'; centerX: number; members: Person[] };
```

- **single**: 1명만 해당 점수대에 있을 때
- **cluster**: 2명 이상이 해당 점수대에 있을 때
- **yOffset**: 스태거 적용 시 ±26px

### 4.3 currentScores 구조

```typescript
{ name: string; score: number; color: string }[]
```

- `color`: `hsl(${(idx * 360) / 16}, 70%, 50%)`로 16명에 균등 분배

### 4.4 이미지 저장 옵션

```typescript
toPng(graphBlockRef.current, {
  backgroundColor: '#ffffff',
  pixelRatio: 2,
  cacheBust: true,
});
```

- 파일명: `{평가자}_{축라벨}_분포_{날짜}.png`

---

## 5. 파일 구조 및 의존성

### 5.1 디렉터리 구조

```
score-graph-app/
├── docs/
│   └── 2026-02-24-log.md     # 이 문서
├── src/
│   ├── App.tsx               # 메인 앱 (평가 UI, 그래프, 저장/불러오기)
│   ├── main.tsx              # React 진입점
│   ├── index.css             # 전역 스타일
│   └── ...
├── index.html
├── package.json
└── ...
```

### 5.2 주요 의존성

| 패키지 | 용도 |
|--------|------|
| react, react-dom | UI |
| html-to-image | 그래프를 PNG로 저장 |
| lucide-react | 아이콘 (User, Download, Upload, Check 등) |
| tailwindcss | 스타일링 |
| vite | 빌드 및 dev 서버 |

### 5.3 스크립트

- `npm run dev`: 개발 서버 실행
- `npm run build`: 프로덕션 빌드
- `npm run preview`: 빌드 결과 미리보기

---

*문서 버전: 2026-02-24*
